<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-type" content="text/html;charset=utf-8">
  <link rel="stylesheet" type="text/css" href="css/gollum.css" media="all">
  <link rel="stylesheet" type="text/css" href="css/editor.css" media="all">
  <link rel="stylesheet" type="text/css" href="css/dialog.css" media="all">
  <link rel="stylesheet" type="text/css" href="css/template.css" media="all">
  
  <!--[if IE 7]>
  <link rel="stylesheet" type="text/css" href="css/ie7.css" media="all">
  <![endif]-->
  
  <script type="text/javascript" src="css/jquery.js"></script>
  <script type="text/javascript" src="css/gollum.js"></script>
  <script type="text/javascript" src="css/gollum.dialog.js"></script>
  <script type="text/javascript" src="css/gollum.placeholder.js"></script>
  
  <script type="text/javascript" 
    src="css/editor/gollum.editor.js"></script>
  <title>Typed Graph</title>
</head>
<body>

<div id="wiki-wrapper" class="page">
<div id="head"><h3><a href="../../index.html">TinkerPop 2.4.0</a> - <a href="Home.html">Frames</a></h3>
  <h1>Typed Graph</h1>
  <ul class="actions">
    <li class="minibutton"><a href="/pages"
      class="action-all-pages">All Pages</a></li>
    <li class="minibutton" class="jaws">
      <a href="#" id="minibutton-new-page">New Page</a></li>
    <li class="minibutton"><a href="/edit/Typed-Graph"
       class="action-edit-page">Edit Page</a></li>
    <li class="minibutton"><a href="/history/Typed-Graph"
       class="action-page-history">Page History</a></li>
  </ul>
  <div id="searchbar">
    <form action="/search" method="get" id="search-form">
    <div id="searchbar-fauxtext">
      <input type="text" name="q" id="search-query" value="Search&hellip;" autocomplete="off">
      <a href="#" id="search-submit" title="Search this wiki">
        <span>Search</span>
      </a>
    </div>
    </form>
  </div></div>
<div id="wiki-content">
  <div class="wrap">
  <div id="wiki-body" class="gollum-textile-content">
    <div id="template">
      <p>Frames can also be configured to store type-information in properties, and to use that information runtime when instantiating objects. For example, consider an object model for relating persons to the pets they own:</p>
<pre><code>interface Person extends VertexFrame {
  @Adjacency(label = "pet") Iterable&lt;? extends Animal&gt; getPets();
  @Adjacency(label = "pet") void addPet(Animal animal);
}

interface Animal extends VertexFrame {
}

interface Fish extends Animal {
}</code></pre>
<h2>The Problem</h2>
<p>Without any extra information Frames isn&#x2019;t aware of the actual types of Animal objects. If you call <code>person.getPets()</code>, all returned objects are Animal-instances. It&#x2019;s not possible to instantiate them as Fish, or Dog, or other sub-classes of Animal, based on runtime information. Likewise, when you call <code>person.addPet(aFish)</code>, the fact that this particular pet is actually a Fish will be lost.</p>
<h2>Frames can Store and Use Type Data</h2>
<p>Since Frames 2.4.0 Frames has support for instantiating polymorphic types, to tackle the above problem, and make runtime decisions about what interfaces to proxy. This is done by telling Frames what the name of each type is, and in which property field that name should be stored:</p>
<ol><li>The root of your class hierarchy (in this case the Animal interface), should be annotated with a <code>TypeField</code> annotation. That annotation contains the property-key in which type information is stored.</li>
	<li>Each concrete (instantiatable) sub-type should be annotated with a <code>TypeValue</code> annotation. That annotation holds the property value that is stored in the property with the key from <code>TypeField</code>.</li>
	<li>A <code>TypedGraphModuleBuilder</code> can be used to make Frames aware of these annotations.</li>
</ol><p>This may lead to the following interface definitions for our Person &#x2192; Pet graph:</p>
<pre><code>interface Person extends VertexFrame {
  @Adjacency(label = "pet") Iterable&lt;? extends Animal&gt; getPets();
  @Adjacency(label = "pet") void addPet(Animal animal);
}

@TypeField("type") interface Animal extends VertexFrame {
}

interface Mammal extends Animal {}

@TypeValue("dog") interface Dog extends Mammal {}

@TypeValue("shepherd") interface Shepherd extends Dog {}

@TypeValue("cat") interface Cat extends Mammal {}

@TypeValue("fish") interface Fish extends Animal {}</code></pre>
<p>Please note that only Animal has a <code>TypeField</code> annotation, because it is the root of our hierarchy. You are not allowed to change the property-key used for storing type information in subtypes of Animal. Also note that both Animal and Mammal don&#x2019;t have <code>TypeValue</code> annotations. This is because pets are typically subtypes of Animal/Mammal, e.g. a Cat, or a Fish. It is not forbidden to have a <code>TypeValue</code> annotation on the same interface that holds the <code>TypeField</code> annotation. It just doesn&#x2019;t make sense in this particular example. Please also note that it&#x2019;s perfectly valid to have TypeValue annotations on subtypes of interfaces that already have a <code>TypeValue</code> annotation, like the Shepherd above, which is a specific type of Dog.</p>
<p>With these extra annotations, Frames is now able to automatically add a <code>type=fish</code> property when storing a vertex that represents a Fish, or <code>type=dog</code> for a Dog. Additionally, Frames may return sub-types of Animal, using the actual property value for <code>type</code>. Thus <code>person.getPets()</code> now returns Dogs, Fishes, etc.</p>
<h2>Using TypedGraphModuleBuilder</h2>
<p>For Frames to actually use the <code>TypeField</code> and <code>TypeValue</code> annotations, a FramedGraph has to know about the interfaces annotated with <code>TypeValue</code>. Since there is no efficient way in Java to get all interfaces that have a specific annotation, your code should tell a FramedGraph where to find those interfaces. For the animal hierarchy in the previous example this may be done as follows:</p>
<pre><code>static final FramedGraphFactory FACTORY = new FramedGraphFactory(
    new TypedGraphModuleBuilder()
        .withClass(Fish.class)
        .withClass(Cat.class)
        .withClass(Dog.class)
        .withClass(Shepherd.class)
        .build()
);</code></pre>
<p>Please note that only the interfaces with <code>TypeValue</code> annotations are given. Frames will detect the <code>TypeField</code> by itself. The <code>FACTORY</code> created this way is reusable and thread-safe once fully initialized. It can be used to create FramedGraphs as follows:</p>
<pre><code>FramedGraph&lt;Graph&gt; framedGraph = FACTORY.create(graph);</code></pre>
<h2><span class="caps">FAQ</span> for Polymorphic Types</h2>
<p><strong>What happens when I frame an element that doesn&#x2019;t have a value for the property defined in TypeField?</strong></p>
<p>Frames will just instantiate the compile time supplied interface (i.e. Animal in the previous examples).</p>
<p><strong>What happens when I frame an element that has an unknown value for the property defined in TypeValue (thus a corresponding TypeValue is missing or not registered)?</strong></p>
<p>Frames will ignore the value, hence will instantiate the compile time supplied interface (i.e. Animal in the previous examples).</p>
<p><strong>What happens when I create a Frame for an interface that has a <code>TypeField</code> in the hierarchy, but no (registered) <code>TypeValue</code> annotation?</strong></p>
<p>No type information will be stored. Thus if you later frame that element, it will be framed as an instance of the compile time supplied interface.</p>
    </div>
  </div>
  </div>

</div>
<div id="footer">
  <p id="last-edit">Last edited by <b>stephen mallette</b>, 2013-08-03 13:20:48</p>
</div>
</div>

<script type="text/javascript" src="css/MathJax/MathJax.js"></script>


</body>
</html>
